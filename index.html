<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>async.lua</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>async.lua</h1>



<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="nowrap">
  <li><strong>async</strong></li>
</ul>
<h2>Source</h2>
<ul class="nowrap">
  <li><a href="source/async.lua.html">async.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>async</code></h1>
<p>Utilities to work with asynchronous callback-style control flow.</p>
<p> All callbacks must adhere to the callback signature: <code>function(err, values...)</code>.
 The first parameter is the error value. It will be <code>nil</code> if no error ocurred, otherwise
 the error value depends on the function that the callback was passed to.
 If no error ocurred, an arbitrary number of return values may be received as second parameter and onward.</p>

<p> Depending on the particular implementation of a function that a callback is passed to, it may be possible to
 receive non-<code>nil</code> return values, even when an error ocurred. Using such return values should be considered undefined
 behavior, unless explicitly documented by the calling function.</p>
    <h3>Info:</h3>
    <ul>
        <li><strong>License</strong>: GPLv3-or-later</li>
    </ul>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" ><a href="#once">once([fn])</a></td>
	<td class="summary">Wraps a function such that it can only ever be called once.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#wrap_sync">wrap_sync(fn)</a></td>
	<td class="summary">Turns an asynchronous function into a blocking operation.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#waterfall">waterfall(tasks, final_callback)</a></td>
	<td class="summary">Executes a list of asynchronous functions in series.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#all">all(tasks, final_callback)</a></td>
	<td class="summary">Runs all tasks in parallel and collects the results.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#dag">dag(tasks, final_callback)</a></td>
	<td class="summary">Resolves a DAG (Directed Acyclic Graph) of asynchronous dependencies.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#do_while">do_while(iteratee, test, final_callback)</a></td>
	<td class="summary">Repeatedly calls <code>test</code> and <code>iteratee</code> until stopped.</td>
	</tr>
	<tr>
	<td class="name" ><a href="#callback">callback([object], fn, ...)</a></td>
	<td class="summary">Wrap a function with arguments for use as callback.</td>
	</tr>
</table>

<br/>
<br/>


    <h2 class="section-header "><a name="Functions"></a>Functions</h2>

    <dl class="function">
    <dt>
    <a name = "once"></a>
    <strong>once([fn])</strong>
    <a style="float:right;" href="source/async.lua.html#30">line 30</a>
    </dt>
    <dd>
    Wraps a function such that it can only ever be called once. </p>

<p> If the returned function is called multiple times, only the first call will result
 in the wrapped function being called. Subsequent calls will be ignored.
 If no function is given, a noop function will be used.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">function</span></span>
         The function to wrap.
         (<em>optional</em>)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>
        The wrapped function or a noop.
    </ol>




</dd>
    <dt>
    <a name = "wrap_sync"></a>
    <strong>wrap_sync(fn)</strong>
    <a style="float:right;" href="source/async.lua.html#56">line 56</a>
    </dt>
    <dd>
    Turns an asynchronous function into a blocking operation. </p>

<p> Using coroutines, this runs a callback-style asynchronous function and blocks until it completes.
 The function to be wrapped may only accept a single parameter: a callback function.
 Return values passed to this callback will be returned as regular values by <code>wrap_sync</code>.</p>

<p> Panics that happened inside the asynchronous function will be captured and re-thrown.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">function</span></span>
         An asynchronous function: <code>function(cb)</code>
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">any</span></span>
        Any return values as passed by the wrapped function
    </ol>




</dd>
    <dt>
    <a name = "waterfall"></a>
    <strong>waterfall(tasks, final_callback)</strong>
    <a style="float:right;" href="source/async.lua.html#89">line 89</a>
    </dt>
    <dd>
    Executes a list of asynchronous functions in series. </p>

<p> <code>waterfall</code> accepts an arbitrary list of asynchronous functions (tasks) and calls them in series.
 Each function waits for the previous one to finish and will be given the previous function&rsquo;s return values.</p>

<p> If an error occurs in any task, execution is stopped immediately, and the final callback is called
 with the error value.
 If all tasks complete successfully, the final callback will be called with the return values of the last
 task in the list.</p>

<p> All tasks must adhere to the callback signature: <code>function(err, ...)</code>.

    <h3>Callback parameters:</h3>
    <ul>
         <li><span class="parameter">err</span> <span class="types">any</span> <span>The error returned by a failing task.</span></li>
         <li><span class="parameter">...</span> <span class="types">any</span> <span>Values as returned by the last task.</span></li>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">tasks</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         The asynchronous tasks to execute in series.
        </li>
        <li><span class="parameter">final_callback</span>
            <span class="types"><span class="type">function</span></span>
         Called when all tasks have finished.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "all"></a>
    <strong>all(tasks, final_callback)</strong>
    <a style="float:right;" href="source/async.lua.html#136">line 136</a>
    </dt>
    <dd>
    Runs all tasks in parallel and collects the results. </p>

<p> If any task produces an error, <code>final_callback</code> will be called immediately
 and remaining tasks will not be tracked.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">tasks</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         A list of asynchronous functions. They will be given a
  callback parameter: <code>function(err, ...)</code>.
        </li>
        <li><span class="parameter">final_callback</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>





</dd>
    <dt>
    <a name = "dag"></a>
    <strong>dag(tasks, final_callback)</strong>
    <a style="float:right;" href="source/async.lua.html#216">line 216</a>
    </dt>
    <dd>
    <p>Resolves a DAG (Directed Acyclic Graph) of asynchronous dependencies. </p>

<p> The task list is a key-value map, where the key defines the task name and the value the is the task definition.
 A task definition consists of a a list of dependencies (which may be empty) and an asynchronous
 function.
 Any task name may be used as dependency for any other task, as long as no loops are created.
 A task&rsquo;s function will be called once all of its dependencies have become available and will be passed a <code>results</code>
 table that contains the values returned by all tasks so far.</p>

<p> If any tasks passes an error to its callback, execution and tracking for all other tasks stops and <code>final_callback</code>
 is called with that error value. Otherwise, <code>final_callback</code> will be called once all tasks have completed, with the
 results of all tasks.</p>

<p> The <code>results</code> table uses the task name as key and provides a <code>table.pack</code>ed list of task results as value.</p>

<p> <strong>Example:</strong></p>

<pre><code> async.dag(
     {
         get_data = { function(cb)
             local f = fs.open("/tmp/foo.txt")
             f:read(cb)
         end },
         make_folder = { function(cb)
             fs.make_folder("/tmp/bar", cb)
         end },
         write_data = { "get_data", "make_folder", function(results, cb)
             local data = table.unpack(results.get_data)
             local f = fs.open("/tmp/bar/foo.txt")
             f:write(data, cb)
         end },
     },
     function(err, results)
         if err ~= nil then
             error(err)
         else
             print("success")
         end
     end
 )
</code></pre>


    <h3>Callback parameters:</h3>
    <ul>
         <li><span class="parameter">err</span> <span class="types">any</span> <span>Any error from a failing task.</span></li>
         <li><span class="parameter">results</span> <span class="types"><a href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span> <span>Results of all resolved tasks.</span></li>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">tasks</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         A map of asynchronous tasks.
        </li>
        <li><span class="parameter">final_callback</span>
            <span class="types"><span class="type">function</span></span>


        </li>
    </ul>





</dd>
    <dt>
    <a name = "do_while"></a>
    <strong>do_while(iteratee, test, final_callback)</strong>
    <a style="float:right;" href="source/async.lua.html#351">line 351</a>
    </dt>
    <dd>
    Repeatedly calls <code>test</code> and <code>iteratee</code> until stopped. </p>

<p> <code>iteratee</code> is called repeatedly. It is passed a callback
 (<code>function(err, ...)</code>), which should be called with either an error or any
 results of the iteration.</p>

<p> <code>test</code> is called once per iteration, after <code>iteratee</code>. It is passed a
 callback (<code>function(err, stop)</code>) and any non-error values from <code>iteratee</code>.
 The callback should be called with either an error or a boolean value.
 Iteration will stop when an error is passed by either callback or when
 <code>test</code> passes a falsy value.</p>

<p> In either case <code>final_callback</code> will be called with the latest results from
 <code>iteratee</code>.</p>

<p> This is, in concept, analogous to a <code>do {} while ()</code> construct, where <code>iteratee</code>
 is the <code>do</code> block and <code>test</code> is the <code>while</code> test.

    <h3>Callback parameters:</h3>
    <ul>
         <li><span class="parameter">err</span> <span class="types">any</span> <span>Any error from <code>iteratee</code> or <code>test</code>.</span></li>
         <li><span class="parameter">...</span> <span class="types">any</span> <span>Values passed by the most recent execution of <code>iteratee</code>.</span></li>
    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">iteratee</span>
            <span class="types"><span class="type">function</span></span>
         Called repeatedly. Signature: <code>function(cb)</code>.
        </li>
        <li><span class="parameter">test</span>
            <span class="types"><span class="type">function</span></span>
         Called once per iteration, after <code>iteratee</code>.
  Signature: <code>function(..., cb)</code>.
        </li>
        <li><span class="parameter">final_callback</span>
            <span class="types"><span class="type">function</span></span>
         Called once, when <code>test</code> indicates to stop
  the iteration.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "callback"></a>
    <strong>callback([object], fn, ...)</strong>
    <a style="float:right;" href="source/async.lua.html#403">line 403</a>
    </dt>
    <dd>
    Wrap a function with arguments for use as callback. </p>

<p> This may be used to wrap a function or table method as a callback, providing a (partial)
 argument list.
 Arguments to this call are passed through to the provided function when it is called,
 arguments from the final caller are appended after those.</p>

<p> If the function is actually a method (i.e. it expects a <code>self</code> parameter or is called with <code>:</code>),
 the <code>self</code> table can be passed as the first argument. Otherwise, <code>nil</code> should be passed.

    </ul>

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">object</span>
            <span class="types"><a class="type" href="https://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         The object to call the method on.
         (<em>optional</em>)
        </li>
        <li><span class="parameter">fn</span>
            <span class="types"><span class="type">function</span></span>
         The function to wrap.
        </li>
        <li><span class="parameter">...</span>
            <span class="types"><span class="type">any</span></span>
         Arbitrary arguments to pass through to the wrapped function.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">function</span></span>


    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.6</a></i>
<i style="float:right;">Last updated 2022-03-03 15:33:18 </i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
